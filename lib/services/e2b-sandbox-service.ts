/**
 * E2B æ²™ç›’æœåŠ¡
 * ä¸“é—¨ä¸º Next.js åº”ç”¨è®¾è®¡çš„ E2B æ²™ç›’ç®¡ç†æœåŠ¡
 * å‚è€ƒ VercelPreviewService çš„è®¾è®¡æ¨¡å¼
 */

import { Sandbox } from '@e2b/code-interpreter';
import { 
  E2BSandboxConfig, 
  E2BSandboxStatus, 
  SandboxInfo, 
  SandboxOperationResult,
  getE2BConfig,
  getDefaultNextjsFiles
} from '@/lib/config/e2b-config';

export type FileMap = Record<string, string>;

export interface DeploymentResult {
  success: boolean;
  url: string;
  sandboxId: string;
  status: E2BSandboxStatus;
  message: string;
  logs?: string[];
}

/**
 * E2B æ²™ç›’é¢„è§ˆæœåŠ¡
 * ä¸¥æ ¼æŒ‰ç…§ E2B å®˜æ–¹æ–‡æ¡£å®ç°
 */
export class E2BSandboxService {
  private sandbox?: Sandbox;
  private config: E2BSandboxConfig;
  private statusListeners: ((status: E2BSandboxStatus) => void)[] = [];
  private logListeners: ((log: string) => void)[] = [];
  private sandboxReadyListeners: ((sandboxInfo: SandboxInfo) => void)[] = [];
  private currentSandbox: SandboxInfo | null = null;
  private sandboxHistory: SandboxInfo[] = [];

  constructor(config?: E2BSandboxConfig) {
    this.config = config || getE2BConfig();
    
    if (!this.config.enabled) {
      console.warn('âš ï¸ E2B æ²™ç›’æœåŠ¡æœªå¯ç”¨');
    }
  }

  // ============== æ ¸å¿ƒæ²™ç›’ç®¡ç†æ–¹æ³• ==============

  /**
   * åˆ›å»º Next.js æ²™ç›’å¹¶åˆå§‹åŒ–ç¯å¢ƒ
   */
  async createNextjsSandbox(): Promise<SandboxInfo> {
    this.emitStatus('initializing');
    this.emitLog('ğŸš€ å¼€å§‹åˆ›å»º Next.js æ²™ç›’...');

    try {
      // 1. åˆ›å»º E2B ä»£ç è§£é‡Šå™¨æ²™ç›’å®ä¾‹
      this.sandbox = await Sandbox.create({
        apiKey: this.config.apiKey,
        timeoutMs: this.config.timeoutMinutes * 60 * 1000,
      });

      this.emitLog(`âœ… æ²™ç›’åˆ›å»ºæˆåŠŸï¼ŒID: ${this.sandbox.sandboxId}`);

      // 2. åˆå§‹åŒ– Next.js ç¯å¢ƒ
      await this.initializeNextjsEnvironment();

      // 3. åˆ›å»ºæ²™ç›’ä¿¡æ¯
      const sandboxInfo: SandboxInfo = {
        id: this.sandbox.sandboxId,
        url: `https://${this.sandbox.getHost(this.config.port)}`,
        status: 'ready',
        createdAt: new Date(),
        lastActivity: new Date(),
        port: this.config.port
      };

      this.currentSandbox = sandboxInfo;
      this.sandboxHistory.push(sandboxInfo);

      this.emitStatus('ready');
      this.emitSandboxReady(sandboxInfo);
      this.emitLog('ğŸ‰ æ²™ç›’å·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹éƒ¨ç½²ä»£ç ï¼');

      return sandboxInfo;

    } catch (error) {
      this.emitStatus('error');
      const errorMessage = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';
      this.emitLog(`âŒ æ²™ç›’åˆ›å»ºå¤±è´¥: ${errorMessage}`);
      throw new Error(`E2B æ²™ç›’åˆ›å»ºå¤±è´¥: ${errorMessage}`);
    }
  }

  /**
   * åˆå§‹åŒ– Next.js ç¯å¢ƒ
   */
  private async initializeNextjsEnvironment(): Promise<void> {
    if (!this.sandbox) {
      throw new Error('æ²™ç›’æœªåˆ›å»º');
    }

    this.emitLog('ğŸ“¦ åˆå§‹åŒ– Next.js ç¯å¢ƒ...');

    try {
      // 1. åˆ›å»ºåŸºç¡€çš„ Next.js é¡¹ç›®ç»“æ„
      const defaultFiles = getDefaultNextjsFiles();
      
      for (const [filename, content] of Object.entries(defaultFiles)) {
        const fileContent = typeof content === 'string' 
          ? content 
          : JSON.stringify(content, null, 2);
          
        await this.sandbox.files.write(filename, fileContent);
        this.emitLog(`ğŸ“„ åˆ›å»ºæ–‡ä»¶: ${filename}`);
      }

      // 2. åˆ›å»ºåŸºç¡€çš„ app ç›®å½•ç»“æ„
      await this.createBasicAppStructure();

      // 3. å®‰è£…åŸºç¡€ä¾èµ–
      this.emitStatus('installing_deps');
      this.emitLog('ğŸ“¦ å®‰è£… Next.js ä¾èµ–...');
      
      const installResult = await this.sandbox.commands.run('cd /home/user && npm install --silent', {
        requestTimeoutMs: 120000 // 2åˆ†é’Ÿè¶…æ—¶
      });
      
      if (installResult.exitCode !== 0) {
        this.emitLog(`âš ï¸ npm install è­¦å‘Š: ${installResult.stderr}`);
      }

      this.emitLog('âœ… Next.js ç¯å¢ƒåˆå§‹åŒ–å®Œæˆ');

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';
      this.emitLog(`âŒ Next.js ç¯å¢ƒåˆå§‹åŒ–å¤±è´¥: ${errorMessage}`);
      throw error;
    }
  }

  /**
   * åˆ›å»ºåŸºç¡€çš„ app ç›®å½•ç»“æ„
   */
  private async createBasicAppStructure(): Promise<void> {
    if (!this.sandbox) return;

    const appFiles = {
      'app/layout.tsx': `import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'E2B Next.js Preview',
  description: 'Generated by HeysMe E2B Preview System',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="zh">
      <body className="antialiased">{children}</body>
    </html>
  )
}`,

      'app/page.tsx': `export default function HomePage() {
  return (
    <main className="min-h-screen flex flex-col items-center justify-center p-8">
      <h1 className="text-4xl font-bold text-center mb-4">
        ğŸš€ E2B Next.js Preview
      </h1>
      <p className="text-lg text-gray-600 text-center mb-8">
        ç”± HeysMe AI é©±åŠ¨çš„å®æ—¶ä»£ç é¢„è§ˆç³»ç»Ÿ
      </p>
      <div className="bg-gray-100 p-6 rounded-lg">
        <p className="text-sm text-gray-500">
          ç­‰å¾… AI ç”Ÿæˆçš„ä»£ç ...
        </p>
      </div>
    </main>
  )
}`,

      'app/globals.css': `@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}`
    };

    for (const [filename, content] of Object.entries(appFiles)) {
      await this.sandbox.files.write(filename, content);
      this.emitLog(`ğŸ“„ åˆ›å»ºåº”ç”¨æ–‡ä»¶: ${filename}`);
    }
  }

  /**
   * éƒ¨ç½²ä»£ç åˆ°æ²™ç›’
   */
  async deployCode(files: FileMap): Promise<DeploymentResult> {
    if (!this.sandbox || !this.currentSandbox) {
      throw new Error('æ²™ç›’æœªåˆ›å»ºï¼Œè¯·å…ˆè°ƒç”¨ createNextjsSandbox()');
    }

    this.emitLog('ğŸš€ å¼€å§‹éƒ¨ç½²ä»£ç ...');

    try {
      // 1. æ£€æµ‹å¹¶å®‰è£…ä¾èµ–
      await this.detectAndInstallDependencies(files);

      // 2. å†™å…¥æ–‡ä»¶
      this.emitLog('ğŸ“ å†™å…¥é¡¹ç›®æ–‡ä»¶...');
      for (const [filename, content] of Object.entries(files)) {
        await this.sandbox.files.write(filename, content);
        this.emitLog(`ğŸ“„ æ›´æ–°æ–‡ä»¶: ${filename}`);
      }

      // 3. é‡å¯å¼€å‘æœåŠ¡å™¨
      await this.restartDevServer();

      // 4. æ›´æ–°æ´»åŠ¨æ—¶é—´
      this.currentSandbox.lastActivity = new Date();

      const result: DeploymentResult = {
        success: true,
        url: this.currentSandbox.url,
        sandboxId: this.currentSandbox.id,
        status: 'ready',
        message: 'ä»£ç éƒ¨ç½²æˆåŠŸï¼'
      };

      this.emitLog('âœ… ä»£ç éƒ¨ç½²å®Œæˆï¼');
      return result;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';
      this.emitLog(`âŒ ä»£ç éƒ¨ç½²å¤±è´¥: ${errorMessage}`);
      
      return {
        success: false,
        url: this.currentSandbox.url,
        sandboxId: this.currentSandbox.id,
        status: 'error',
        message: `éƒ¨ç½²å¤±è´¥: ${errorMessage}`
      };
    }
  }

  /**
   * æ™ºèƒ½æ£€æµ‹å¹¶å®‰è£…ä¾èµ–
   */
  private async detectAndInstallDependencies(files: FileMap): Promise<void> {
    this.emitLog('ğŸ” æ£€æµ‹é¡¹ç›®ä¾èµ–...');

    // æ‰«ææ‰€æœ‰æ–‡ä»¶ä¸­çš„ import è¯­å¥
    const imports = new Set<string>();
    const importRegex = /import\s+.*from\s+['"]([^'"]+)['"]/g;

    for (const [filename, content] of Object.entries(files)) {
      let match;
      while ((match = importRegex.exec(content)) !== null) {
        const importPath = match[1];
        // åªæ”¶é›† npm åŒ…ï¼Œæ’é™¤ç›¸å¯¹è·¯å¾„å’Œå†…ç½®æ¨¡å—
        if (!importPath.startsWith('.') && !importPath.startsWith('/') && !importPath.startsWith('next/')) {
          imports.add(importPath.split('/')[0]); // è·å–åŒ…åçš„æ ¹éƒ¨åˆ†
        }
      }
    }

    if (imports.size === 0) {
      this.emitLog('âœ… æœªæ£€æµ‹åˆ°æ–°çš„ä¾èµ–åŒ…');
      return;
    }

    const packages = Array.from(imports);
    this.emitLog(`ğŸ“¦ æ£€æµ‹åˆ°ä¾èµ–: ${packages.join(', ')}`);

    // æ£€æŸ¥å“ªäº›åŒ…éœ€è¦å®‰è£…
    const packagesToInstall: string[] = [];
    
    for (const pkg of packages) {
      try {
        await this.sandbox!.runCode(`test -d node_modules/${pkg} || echo "missing:${pkg}"`);
      } catch (error) {
        packagesToInstall.push(pkg);
      }
    }

    if (packagesToInstall.length > 0) {
      this.emitStatus('installing_deps');
      this.emitLog(`ğŸ“¦ å®‰è£…ç¼ºå¤±çš„ä¾èµ–: ${packagesToInstall.join(', ')}`);
      
      await this.sandbox!.runCode(`
cd /home/user
npm install ${packagesToInstall.join(' ')} --silent
echo "ä¾èµ–å®‰è£…å®Œæˆ"
      `);

      this.emitLog('âœ… ä¾èµ–å®‰è£…å®Œæˆ');
    } else {
      this.emitLog('âœ… æ‰€æœ‰ä¾èµ–éƒ½å·²å®‰è£…');
    }
  }

  /**
   * é‡å¯å¼€å‘æœåŠ¡å™¨
   */
  private async restartDevServer(): Promise<void> {
    if (!this.sandbox) return;

    this.emitStatus('starting_server');
    this.emitLog('ğŸ”„ é‡å¯ Next.js å¼€å‘æœåŠ¡å™¨...');

    try {
      // åœæ­¢ç°æœ‰çš„æœåŠ¡å™¨ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
      await this.sandbox.commands.run('cd /home/user && pkill -f "next dev" || true', {
        requestTimeoutMs: 10000
      });
      this.emitLog('ğŸ›‘ å·²åœæ­¢ç°æœ‰çš„ Next.js æœåŠ¡å™¨');

      // å¯åŠ¨æ–°çš„å¼€å‘æœåŠ¡å™¨ï¼ˆåå°è¿è¡Œï¼‰
      const serverHandle = await this.sandbox.commands.run('cd /home/user && npm run dev', {
        background: true,
        onStdout: (data) => this.emitLog(`[Next.js] ${data}`),
        onStderr: (data) => this.emitLog(`[Next.js Error] ${data}`)
      });

      // ç­‰å¾…æœåŠ¡å™¨å¯åŠ¨
      await new Promise(resolve => setTimeout(resolve, this.config.startupTimeout));

      this.emitLog('âœ… Next.js å¼€å‘æœåŠ¡å™¨å·²é‡å¯');
      this.emitStatus('ready');

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';
      this.emitLog(`âŒ å¼€å‘æœåŠ¡å™¨é‡å¯å¤±è´¥: ${errorMessage}`);
      throw error;
    }
  }

  /**
   * è·å–æ²™ç›’çŠ¶æ€
   */
  async getSandboxStatus(): Promise<SandboxOperationResult> {
    if (!this.sandbox || !this.currentSandbox) {
      return {
        success: false,
        message: 'æ²™ç›’æœªåˆ›å»º',
        error: 'NO_SANDBOX'
      };
    }

    try {
      // æ£€æŸ¥æ²™ç›’æ˜¯å¦è¿˜æ´»è·ƒ
      await this.sandbox.commands.run('echo "ping"', { requestTimeoutMs: 5000 });
      
      return {
        success: true,
        message: 'æ²™ç›’è¿è¡Œæ­£å¸¸',
        data: this.currentSandbox
      };
    } catch (error) {
      return {
        success: false,
        message: 'æ²™ç›’è¿æ¥å¤±è´¥',
        error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  /**
   * é”€æ¯æ²™ç›’
   */
  async destroySandbox(): Promise<SandboxOperationResult> {
    if (!this.sandbox) {
      return {
        success: true,
        message: 'æ²™ç›’å·²ä¸å­˜åœ¨'
      };
    }

    try {
      await this.sandbox.kill();
      this.sandbox = undefined;
      this.currentSandbox = null;
      
      this.emitLog('ğŸ—‘ï¸ æ²™ç›’å·²é”€æ¯');
      
      return {
        success: true,
        message: 'æ²™ç›’é”€æ¯æˆåŠŸ'
      };
    } catch (error) {
      return {
        success: false,
        message: 'æ²™ç›’é”€æ¯å¤±è´¥',
        error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  // ============== äº‹ä»¶ç›‘å¬å™¨æ–¹æ³• ==============

  addStatusListener(callback: (status: E2BSandboxStatus) => void): void {
    this.statusListeners.push(callback);
  }

  addLogListener(callback: (log: string) => void): void {
    this.logListeners.push(callback);
  }

  addSandboxReadyListener(callback: (sandboxInfo: SandboxInfo) => void): void {
    this.sandboxReadyListeners.push(callback);
  }

  private emitStatus(status: E2BSandboxStatus): void {
    this.statusListeners.forEach(callback => callback(status));
  }

  private emitLog(log: string): void {
    console.log(`[E2B] ${log}`);
    this.logListeners.forEach(callback => callback(log));
  }

  private emitSandboxReady(sandboxInfo: SandboxInfo): void {
    this.sandboxReadyListeners.forEach(callback => callback(sandboxInfo));
  }

  // ============== å·¥å…·æ–¹æ³• ==============

  getCurrentSandbox(): SandboxInfo | null {
    return this.currentSandbox;
  }

  getSandboxHistory(): SandboxInfo[] {
    return [...this.sandboxHistory];
  }

  isEnabled(): boolean {
    return this.config.enabled;
  }

  getPreviewUrl(): string {
    return this.currentSandbox?.url || '';
  }
}
