/**
 * E2B 沙盒服务
 * 专门为 Next.js 应用设计的 E2B 沙盒管理服务
 * 参考 VercelPreviewService 的设计模式
 */

import { Sandbox } from '@e2b/code-interpreter';
import { 
  E2BSandboxConfig, 
  E2BSandboxStatus, 
  SandboxInfo, 
  SandboxOperationResult,
  getE2BConfig,
  getDefaultNextjsFiles
} from '@/lib/config/e2b-config';

export type FileMap = Record<string, string>;

export interface DeploymentResult {
  success: boolean;
  url: string;
  sandboxId: string;
  status: E2BSandboxStatus;
  message: string;
  logs?: string[];
}

/**
 * E2B 沙盒预览服务
 * 严格按照 E2B 官方文档实现
 */
export class E2BSandboxService {
  private sandbox?: Sandbox;
  private config: E2BSandboxConfig;
  private statusListeners: ((status: E2BSandboxStatus) => void)[] = [];
  private logListeners: ((log: string) => void)[] = [];
  private sandboxReadyListeners: ((sandboxInfo: SandboxInfo) => void)[] = [];
  private currentSandbox: SandboxInfo | null = null;
  private sandboxHistory: SandboxInfo[] = [];

  constructor(config?: E2BSandboxConfig) {
    this.config = config || getE2BConfig();
    
    if (!this.config.enabled) {
      console.warn('⚠️ E2B 沙盒服务未启用');
    }
  }

  // ============== 核心沙盒管理方法 ==============

  /**
   * 创建 Next.js 沙盒并初始化环境
   */
  async createNextjsSandbox(): Promise<SandboxInfo> {
    this.emitStatus('initializing');
    this.emitLog('🚀 开始创建 Next.js 沙盒...');

    try {
      // 1. 创建 E2B 代码解释器沙盒实例
      this.sandbox = await Sandbox.create({
        apiKey: this.config.apiKey,
        timeoutMs: this.config.timeoutMinutes * 60 * 1000,
      });

      this.emitLog(`✅ 沙盒创建成功，ID: ${this.sandbox.sandboxId}`);

      // 2. 初始化 Next.js 环境
      await this.initializeNextjsEnvironment();

      // 3. 创建沙盒信息
      const sandboxInfo: SandboxInfo = {
        id: this.sandbox.sandboxId,
        url: `https://${this.sandbox.getHost(this.config.port)}`,
        status: 'ready',
        createdAt: new Date(),
        lastActivity: new Date(),
        port: this.config.port
      };

      this.currentSandbox = sandboxInfo;
      this.sandboxHistory.push(sandboxInfo);

      this.emitStatus('ready');
      this.emitSandboxReady(sandboxInfo);
      this.emitLog('🎉 沙盒已就绪，可以开始部署代码！');

      return sandboxInfo;

    } catch (error) {
      this.emitStatus('error');
      const errorMessage = error instanceof Error ? error.message : '未知错误';
      this.emitLog(`❌ 沙盒创建失败: ${errorMessage}`);
      throw new Error(`E2B 沙盒创建失败: ${errorMessage}`);
    }
  }

  /**
   * 初始化 Next.js 环境
   */
  private async initializeNextjsEnvironment(): Promise<void> {
    if (!this.sandbox) {
      throw new Error('沙盒未创建');
    }

    this.emitLog('📦 初始化 Next.js 环境...');

    try {
      // 1. 创建基础的 Next.js 项目结构
      const defaultFiles = getDefaultNextjsFiles();
      
      for (const [filename, content] of Object.entries(defaultFiles)) {
        const fileContent = typeof content === 'string' 
          ? content 
          : JSON.stringify(content, null, 2);
          
        await this.sandbox.files.write(filename, fileContent);
        this.emitLog(`📄 创建文件: ${filename}`);
      }

      // 2. 创建基础的 app 目录结构
      await this.createBasicAppStructure();

      // 3. 安装基础依赖
      this.emitStatus('installing_deps');
      this.emitLog('📦 安装 Next.js 依赖...');
      
      const installResult = await this.sandbox.commands.run('cd /home/user && npm install --silent', {
        requestTimeoutMs: 120000 // 2分钟超时
      });
      
      if (installResult.exitCode !== 0) {
        this.emitLog(`⚠️ npm install 警告: ${installResult.stderr}`);
      }

      this.emitLog('✅ Next.js 环境初始化完成');

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : '未知错误';
      this.emitLog(`❌ Next.js 环境初始化失败: ${errorMessage}`);
      throw error;
    }
  }

  /**
   * 创建基础的 app 目录结构
   */
  private async createBasicAppStructure(): Promise<void> {
    if (!this.sandbox) return;

    const appFiles = {
      'app/layout.tsx': `import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'E2B Next.js Preview',
  description: 'Generated by HeysMe E2B Preview System',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="zh">
      <body className="antialiased">{children}</body>
    </html>
  )
}`,

      'app/page.tsx': `export default function HomePage() {
  return (
    <main className="min-h-screen flex flex-col items-center justify-center p-8">
      <h1 className="text-4xl font-bold text-center mb-4">
        🚀 E2B Next.js Preview
      </h1>
      <p className="text-lg text-gray-600 text-center mb-8">
        由 HeysMe AI 驱动的实时代码预览系统
      </p>
      <div className="bg-gray-100 p-6 rounded-lg">
        <p className="text-sm text-gray-500">
          等待 AI 生成的代码...
        </p>
      </div>
    </main>
  )
}`,

      'app/globals.css': `@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}`
    };

    for (const [filename, content] of Object.entries(appFiles)) {
      await this.sandbox.files.write(filename, content);
      this.emitLog(`📄 创建应用文件: ${filename}`);
    }
  }

  /**
   * 部署代码到沙盒
   */
  async deployCode(files: FileMap): Promise<DeploymentResult> {
    if (!this.sandbox || !this.currentSandbox) {
      throw new Error('沙盒未创建，请先调用 createNextjsSandbox()');
    }

    this.emitLog('🚀 开始部署代码...');

    try {
      // 1. 检测并安装依赖
      await this.detectAndInstallDependencies(files);

      // 2. 写入文件
      this.emitLog('📝 写入项目文件...');
      for (const [filename, content] of Object.entries(files)) {
        await this.sandbox.files.write(filename, content);
        this.emitLog(`📄 更新文件: ${filename}`);
      }

      // 3. 重启开发服务器
      await this.restartDevServer();

      // 4. 更新活动时间
      this.currentSandbox.lastActivity = new Date();

      const result: DeploymentResult = {
        success: true,
        url: this.currentSandbox.url,
        sandboxId: this.currentSandbox.id,
        status: 'ready',
        message: '代码部署成功！'
      };

      this.emitLog('✅ 代码部署完成！');
      return result;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : '未知错误';
      this.emitLog(`❌ 代码部署失败: ${errorMessage}`);
      
      return {
        success: false,
        url: this.currentSandbox.url,
        sandboxId: this.currentSandbox.id,
        status: 'error',
        message: `部署失败: ${errorMessage}`
      };
    }
  }

  /**
   * 智能检测并安装依赖
   */
  private async detectAndInstallDependencies(files: FileMap): Promise<void> {
    this.emitLog('🔍 检测项目依赖...');

    // 扫描所有文件中的 import 语句
    const imports = new Set<string>();
    const importRegex = /import\s+.*from\s+['"]([^'"]+)['"]/g;

    for (const [filename, content] of Object.entries(files)) {
      let match;
      while ((match = importRegex.exec(content)) !== null) {
        const importPath = match[1];
        // 只收集 npm 包，排除相对路径和内置模块
        if (!importPath.startsWith('.') && !importPath.startsWith('/') && !importPath.startsWith('next/')) {
          imports.add(importPath.split('/')[0]); // 获取包名的根部分
        }
      }
    }

    if (imports.size === 0) {
      this.emitLog('✅ 未检测到新的依赖包');
      return;
    }

    const packages = Array.from(imports);
    this.emitLog(`📦 检测到依赖: ${packages.join(', ')}`);

    // 检查哪些包需要安装
    const packagesToInstall: string[] = [];
    
    for (const pkg of packages) {
      try {
        await this.sandbox!.runCode(`test -d node_modules/${pkg} || echo "missing:${pkg}"`);
      } catch (error) {
        packagesToInstall.push(pkg);
      }
    }

    if (packagesToInstall.length > 0) {
      this.emitStatus('installing_deps');
      this.emitLog(`📦 安装缺失的依赖: ${packagesToInstall.join(', ')}`);
      
      await this.sandbox!.runCode(`
cd /home/user
npm install ${packagesToInstall.join(' ')} --silent
echo "依赖安装完成"
      `);

      this.emitLog('✅ 依赖安装完成');
    } else {
      this.emitLog('✅ 所有依赖都已安装');
    }
  }

  /**
   * 重启开发服务器
   */
  private async restartDevServer(): Promise<void> {
    if (!this.sandbox) return;

    this.emitStatus('starting_server');
    this.emitLog('🔄 重启 Next.js 开发服务器...');

    try {
      // 停止现有的服务器（如果有的话）
      await this.sandbox.commands.run('cd /home/user && pkill -f "next dev" || true', {
        requestTimeoutMs: 10000
      });
      this.emitLog('🛑 已停止现有的 Next.js 服务器');

      // 启动新的开发服务器（后台运行）
      const serverHandle = await this.sandbox.commands.run('cd /home/user && npm run dev', {
        background: true,
        onStdout: (data) => this.emitLog(`[Next.js] ${data}`),
        onStderr: (data) => this.emitLog(`[Next.js Error] ${data}`)
      });

      // 等待服务器启动
      await new Promise(resolve => setTimeout(resolve, this.config.startupTimeout));

      this.emitLog('✅ Next.js 开发服务器已重启');
      this.emitStatus('ready');

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : '未知错误';
      this.emitLog(`❌ 开发服务器重启失败: ${errorMessage}`);
      throw error;
    }
  }

  /**
   * 获取沙盒状态
   */
  async getSandboxStatus(): Promise<SandboxOperationResult> {
    if (!this.sandbox || !this.currentSandbox) {
      return {
        success: false,
        message: '沙盒未创建',
        error: 'NO_SANDBOX'
      };
    }

    try {
      // 检查沙盒是否还活跃
      await this.sandbox.commands.run('echo "ping"', { requestTimeoutMs: 5000 });
      
      return {
        success: true,
        message: '沙盒运行正常',
        data: this.currentSandbox
      };
    } catch (error) {
      return {
        success: false,
        message: '沙盒连接失败',
        error: error instanceof Error ? error.message : '未知错误'
      };
    }
  }

  /**
   * 销毁沙盒
   */
  async destroySandbox(): Promise<SandboxOperationResult> {
    if (!this.sandbox) {
      return {
        success: true,
        message: '沙盒已不存在'
      };
    }

    try {
      await this.sandbox.kill();
      this.sandbox = undefined;
      this.currentSandbox = null;
      
      this.emitLog('🗑️ 沙盒已销毁');
      
      return {
        success: true,
        message: '沙盒销毁成功'
      };
    } catch (error) {
      return {
        success: false,
        message: '沙盒销毁失败',
        error: error instanceof Error ? error.message : '未知错误'
      };
    }
  }

  // ============== 事件监听器方法 ==============

  addStatusListener(callback: (status: E2BSandboxStatus) => void): void {
    this.statusListeners.push(callback);
  }

  addLogListener(callback: (log: string) => void): void {
    this.logListeners.push(callback);
  }

  addSandboxReadyListener(callback: (sandboxInfo: SandboxInfo) => void): void {
    this.sandboxReadyListeners.push(callback);
  }

  private emitStatus(status: E2BSandboxStatus): void {
    this.statusListeners.forEach(callback => callback(status));
  }

  private emitLog(log: string): void {
    console.log(`[E2B] ${log}`);
    this.logListeners.forEach(callback => callback(log));
  }

  private emitSandboxReady(sandboxInfo: SandboxInfo): void {
    this.sandboxReadyListeners.forEach(callback => callback(sandboxInfo));
  }

  // ============== 工具方法 ==============

  getCurrentSandbox(): SandboxInfo | null {
    return this.currentSandbox;
  }

  getSandboxHistory(): SandboxInfo[] {
    return [...this.sandboxHistory];
  }

  isEnabled(): boolean {
    return this.config.enabled;
  }

  getPreviewUrl(): string {
    return this.currentSandbox?.url || '';
  }
}
